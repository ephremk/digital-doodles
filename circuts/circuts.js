// Generated by CoffeeScript 1.6.3
(function() {
  var Cicuit, circuits, colors, density, height, width;

  density = window.devicePixelRatio || 1;

  width = window.innerWidth * density;

  height = window.innerHeight * density;

  colors = ["#f9d100", "#a1fa00", "#f9be83", "#cc9cde", "#ece78c", "#40a3e5"];

  circuits = [];

  window.onload = function() {
    var canvas, ctx, thread, tick;
    thread = 0;
    canvas = document.createElement('canvas');
    canvas.setAttribute('width', width);
    canvas.setAttribute('height', height);
    canvas.style.width = width / density + "px";
    canvas.style.height = height / density + "px";
    document.body.appendChild(canvas);
    ctx = canvas.getContext('2d');
    tick = function() {
      if (this.last && (this.last.x > width || this.last.y > height || this.last.y < 0) && ++thread) {
        this.last = void 0;
      }
      this.last = new Cicuit(this.last, ctx, thread);
      return circuits.push(this.last.draw(ctx));
    };
    return setInterval(tick, 100);
  };

  Cicuit = (function() {
    Cicuit.prototype.orbSize = function() {
      return Math.random() * 3 + 2 * density;
    };

    function Cicuit(last, ctx, thread) {
      if (last) {
        this.connectToLast(last, ctx);
      } else {
        this.x = 0;
        this.y = Math.random() * height;
      }
      this.thread = thread;
      this.orbs = [this.orbSize(), this.orbSize()];
      this.distance = 10 * density + 10 * density;
    }

    Cicuit.prototype.posNeg = function() {
      if (~~(Math.random() * 2)) {
        return 1;
      } else {
        return -1;
      }
    };

    Cicuit.prototype.connectNear = function(ctx) {
      var c, i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = circuits.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        c = circuits[i];
        if (this.thread !== c.thread && Math.abs(this.x - c.x) < 50 * density && Math.abs(this.y - c.y) < 50 * density) {
          ctx.strokeStyle = "rgba(0, 0, 0, 0.1)";
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(c.x, c.y);
          ctx.stroke();
          _results.push(ctx.closePath());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Cicuit.prototype.connectToLast = function(last, ctx) {
      var lastEnd, nextStart, seperation, shift;
      lastEnd = last.x + last.distance + last.orbs[1];
      shift = Math.random() * 40 * density;
      seperation = {
        x: shift,
        y: shift * this.posNeg()
      };
      nextStart = {
        x: lastEnd + seperation.x,
        y: last.y + last.orbs[1] + seperation.y
      };
      this.drawLine(ctx, lastEnd, last.y, seperation.x, seperation.y);
      this.x = nextStart.x;
      return this.y = nextStart.y;
    };

    Cicuit.prototype.drawOrb = function(x, y, rad, ctx) {
      ctx.beginPath();
      switch (~~(Math.random() * 4)) {
        case 0:
          ctx.arc(x, y, rad, 2 * Math.PI, 0);
          ctx.fillStyle = colors[~~(Math.random() * colors.length)];
          ctx.fill();
          break;
        case 1:
          ctx.rect(x - rad / 2, y - rad / 2, rad, rad);
          ctx.strokeStyle = colors[~~(Math.random() * colors.length)];
          ctx.fillStyle = colors[~~(Math.random() * colors.length)];
          ctx.stroke();
          ctx.fill();
          break;
        case 2:
          ctx.arc(x, y, rad, 2 * Math.PI, 0);
          ctx.fillStyle = colors[~~(Math.random() * colors.length)];
          ctx.fill();
          ctx.closePath();
          ctx.beginPath();
          ctx.arc(x, y, rad * .7, 2 * Math.PI, 0);
          ctx.fillStyle = colors[~~(Math.random() * colors.length)];
          ctx.fill();
          break;
        case 3:
          ctx.strokeStyle = colors[~~(Math.random() * colors.length)];
          ctx.lineWidth = density;
          ctx.rect(x - rad / 2, y - rad / 2, rad, rad);
          ctx.stroke();
          ctx.lineWidth = 0.5 * density;
      }
      return ctx.closePath();
    };

    Cicuit.prototype.draw = function(ctx) {
      var i, _i;
      this.drawLine(ctx, this.x, this.y, this.distance);
      for (i = _i = 0; _i < 2; i = ++_i) {
        this.drawOrb(this.x + this.distance * i, this.y, this.orbs[i] * density, ctx);
      }
      this.connectNear(ctx);
      return this;
    };

    Cicuit.prototype.drawLine = function(ctx, x, y, distanceX, distanceY) {
      if (distanceY == null) {
        distanceY = 0;
      }
      ctx.lineWidth = 0.5 * density;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + distanceX, y + distanceY);
      ctx.strokeStyle = "rgba(0,0,0,0.2)";
      ctx.stroke();
      return ctx.closePath();
    };

    return Cicuit;

  })();

}).call(this);
